#!/usr/bin/env ruby
# coding: utf-8

require "mcrain"

action, service, *args  = *ARGV
verbose = ARGV.include?('-V') || ARGV.include?('--verbose')
if action.nil? || service.nil?
  $stderr.puts(<<MESSAGE)
#{$PROGRAM_NAME} <action> <service> [n] [-v or --verbose]
  actions: start, stop or pull

  start:
    service: redis, rabbitmq, mysql or riak
      n: cluster size for riak

  stop:
    service: redis, rabbitmq, mysql or riak

  pull:
    service: redis, rabbitmq, mysql, riak or all
MESSAGE

  exit(1)
end

unless args.include?("-v") || args.include?("--verbose")
  require 'logger'
  Mcrain.logger = Logger.new("/dev/null")
end

begin
  options = {}
  case service
  when "riak" then
    cluster_size = args.shift.to_i
    cluster_size = 1 if cluster_size == 0
    options = {cluster_size: cluster_size, automatic_clustering: cluster_size > 1}
  end

  case action
  when "start", "stop" then
    server = Mcrain.lookup(service.to_sym, options)
    server.send(action)
  when "pull" then
    services = (service == "all") ? [:mysql, :redis, :rabbitmq, :riak] : [service.to_sym]
    services.map{|s| Mcrain.class_for(s.to_sym)}.each(&:pull_image)
  else
    raise "Unknown action: #{action.inspect}"
  end

  case action
  when "start" then
    puts "To connect:\nrequire '#{server.client_require}'\nclient = #{server.client_script}"
  end
rescue => e
  $stderr.puts "\e[31m[#{e.class}] #{e.message}\e[0m"
  $stderr.puts e.backtrace.join("\n  ") if verbose
  exit(1)
else
  $stderr.puts "\e[32mOK\e[0m"
  exit(0)
end
