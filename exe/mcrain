#!/usr/bin/env ruby
# coding: utf-8

require "mcrain"

action, service, *args  = *ARGV
verbose = ARGV.include?('-V') || ARGV.include?('--verbose')
if action.nil? || service.nil?
  $stderr.puts(<<MESSAGE)
#{$PROGRAM_NAME} <action> <service> [n] [-v or --verbose]
  actions: start, stop or pull

  start:
    service: redis, rabbitmq, mysql or riak
      n: cluster size for riak

  stop:
    service: redis, rabbitmq, mysql or riak

  pull:
    service: redis, rabbitmq, mysql, riak or all
MESSAGE

  exit(1)
end

unless args.include?("-v") || args.include?("--verbose")
  require 'logger'
  Mcrain.logger = Logger.new("/dev/null")
end

begin
  options = {}
  case service
  when "riak" then
    cluster_size = args.shift.to_i
    cluster_size = 1 if cluster_size == 0
    options = {cluster_size: cluster_size, automatic_clustering: cluster_size > 1}
  end

  cid_filepath = ".mcrain.#{service}.cid"
  case action
  when "start" then
    if File.exist?(cid_filepath)
      $stderr.puts("\e[31m#{service} is already run on docker. Check #{cid_filepath}\e[0m")
      exit(1)
    else
      server = Mcrain.class_for(service.to_sym).new(options)
      container = server.start
      open(cid_filepath, "w"){|f| f.puts(container.id)}
      puts "To connect:\n#{server.client_script}"
    end
  when "stop" then
    if File.readable?(cid_filepath)
      cid = File.read(cid_filepath).strip
      if system("docker kill #{cid} && docker rm #{cid} >/dev/null")
        File.delete(cid_filepath)
      else
        $stderr.puts("\e[31mFailed to stop or rm container #{cid}. `rm #{cid_filepath}` unless the container exists.\e[0m")
        exit(1)
      end
    else
      $stderr.puts("\e[31m#{service} container is not found.\e[0m")
      exit(1)
    end
  when "pull" then
    services = (service == "all") ? Mcrain.images.keys : [service]
    services.map(&:to_sym).map{|s| Mcrain.class_for(s)}.each(&:pull_image)
  else
    raise "Unknown action: #{action.inspect}"
  end

rescue => e
  $stderr.puts "\e[31m[#{e.class}] #{e.message}\e[0m"
  $stderr.puts e.backtrace.join("\n  ") if verbose
  exit(1)
else
  $stderr.puts "\e[32mOK\e[0m"
  exit(0)
end
